package com.backEnd;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

/**
 * This class is responsible for parsing the metadata files. it converts each
 * metadata file into a 2D ArrayList, where each element is an
 * ArrayList is a column within the metadata file. This allows for
 * metadata data to be accesssed easily by the GUI and the pre-processing steps
 * in DiffExCalc.java.
 * 
 * @author Agastya Sharma Date: July 14th, 2017
 * @version 1.0
 */

public class MetaDataParser {
	/**
	 * This method is responsible for converting the file into a list
	 * representation.
	 * 
	 * @param f:
	 *            metadata file
	 * 
	 * @return metadata file as a list. Each element in the list is a arrayList
	 *         representing a column in the file.
	 * 
	 * @throws IOException
	 *             caused by FileInputStream
	 */
	public static ArrayList<ArrayList<String>> parse(File f) throws IOException {
		// list of parameters specificed in the file
		ArrayList<ArrayList<String>> paramsList = new ArrayList<ArrayList<String>>();
		FileInputStream in = new FileInputStream(f);
		Scanner scan = new Scanner(f);
		// adds lists for each column to the 2D list
		String[] splits = scan.nextLine().split(",");
		for (int i = 0; i < splits.length; i++) {
			paramsList.add(new ArrayList<String>());
		}
		// populates each column array with unique elements (such that there are
		// no duplicates within any list)
		while (scan.hasNext()) {
			splits = scan.nextLine().split(",");
			for (int i = 0; i < splits.length; i++) {
				if (!paramsList.get(i).contains(splits[i])) {
					paramsList.get(i).add(splits[i]);
				}
			}
		}
		in.close();
		scan.close();
		return paramsList;
	}

	// makes data files
	private static String[] DataNameGenerator(File folder, String foldername) {
		File[] toReturn = new File[folder.listFiles(Config.FileFilter).length];
		int i = 0;
		for (File f : folder.listFiles(Config.FileFilter)) {
			String g = f.getName().replace("metadata_", "");
			File j = new File(foldername + "/" + g);
			toReturn[i] = j;
			i++;
		}
		String[] ret = new String[toReturn.length];
		for (int k = 0; k < ret.length; k++) {
			ret[k] = toReturn[k].getAbsolutePath();
		}
		return ret;
	}

	/**
	 * This method is currently unused. Before the comparisons were displayed to
	 * the user, the user would have to provide a file that had the comparisons
	 * to run specified and broken up by metadata file. This method would parse
	 * that file and pass the comparisons to the R script. However, this
	 * approach was made obsolete by getPerms() and generatePerm()
	 * 
	 * @param tests:
	 *            name of comparisons file
	 * 
	 * @return ArrayList of ArrayLists of comparisons per metadata file
	 * 
	 * @throws IOException
	 *             caused by FileInputStream
	 * 
	 */
	public static ArrayList<ArrayList<String>> getComps(String tests) throws IOException {
		File test = new File(tests);
		FileInputStream f = new FileInputStream(test);
		Scanner scans = new Scanner(f);
		// the word "cut" was used to delimit the comparisons per metadata file
		scans.useDelimiter("Cut");
		ArrayList<ArrayList<String>> filesTests = new ArrayList<ArrayList<String>>();
		while (scans.hasNext()) {
			String s = scans.next();
			ArrayList<String> temp = new ArrayList<>(Arrays.asList(s.split("\n")));
			filesTests.add(temp);
		}

		// removed any lists with no comparisons
		for (ArrayList<String> s : filesTests) {
			for (int i = 0; i < s.size(); i++) {
				if (s.get(i).length() == 0) {
					s.remove(i);
				}
			}
		}
		scans.close();
		f.close();
		return filesTests;
	}

	/**
	 * method called to execute the GeneratePermutations algorithm. This shell
	 * method allows for the ArrayList of data subsets to be returned to the
	 * user.
	 * 
	 * @param lists:
	 *            lists to generate permutations from (usually takes in the
	 *           2D String ArrayList generated by the parse() method.
	 * 
	 * @return ArrayList of combined elements
	 * 
	 */
	public static ArrayList<String> getPerms(ArrayList<ArrayList<String>> lists) {
		if (lists == null || lists.isEmpty()) {
			return null;
		} else {
			ArrayList<String> res = new ArrayList<String>();
			GeneratePermutations(lists, res, 0, "");
			return res;
		}
	}

	/**
	 * This method takes all Strings in an ArrayList and generates a new list
	 * with all combinations of elements within the single list. It is used to
	 * generate comparisons displayed to the user by the GUI.
	 * 
	 * A DESeq2 comparison requires combining all possible combinations of
	 * elements in the metadata file columns first to generate data subsets to
	 * compare, and then combining those combinations to actually generate
	 * comparisons. This method performs the first step: combining all elements
	 * in a 2D arrayList into a single one.
	 * 
	 * @param Lists:
	 *            ArrayList of arrayLists to combine
	 * @param result:
	 *            ArrayList to store resulting combinations
	 * @param depth:
	 *            used to keep index in 2D arrayList
	 * @param current:
	 *            temporary String value placeholder
	 * 
	 * 
	 */

	private static void GeneratePermutations(ArrayList<ArrayList<String>> Lists, ArrayList<String> result, int depth,
			String current) {
		if (depth == Lists.size()) {
			result.add(current);
			return;
		}

		for (int i = 0; i < Lists.get(depth).size(); ++i) {
			GeneratePermutations(Lists, result, depth + 1, current + Lists.get(depth).get(i));
		}

	}

	/**
	 * This method takes all Strings in an ArrayList and generates a new list
	 * with all combinations of elements within the single list. It is used to
	 * generate comparisons displayed to the user by the GUI.
	 * 
	 * @param a:
	 *            ArrayList of elements to combine
	 * 
	 * @return ArrayList of combined elements
	 * 
	 */

	public static ArrayList<String> generatePerm(ArrayList<String> a) {
		ArrayList<String> toReturn = new ArrayList<String>();
		for (int i = 0; i < a.size(); i++) {
			for (int j = i; j < a.size(); j++) {
				if (a.get(i) != a.get(j)) {
					// adds the "vs" to make the comparison presentable to the
					// user.
					toReturn.add(a.get(i) + "vs" + a.get(j));
				}
			}
		}
		return toReturn;
	}
}
